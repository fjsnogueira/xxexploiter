import fs from 'fs';
import * as Axios from 'axios';
import * as Https from 'https';
import { Method } from 'axios';
import { PayloadGenerator } from './PayloadGenerator';

export class Requester {

  public static async fromTemplate(templatePath: string, payload: string): Promise<any> {
    return new Promise((resolve, reject) => {

      fs.readFile(templatePath, (err, data: Buffer) => {
        if (err) { console.error(err); return; }

        try {
          const fileContent = data.toString();
          const firstNewLineIndex = fileContent.indexOf("\n");
          const startLine = fileContent.substring(0);
          const startLineArray = startLine.split(" ");
          const method: Method = startLineArray[0] as Method;
          const path = startLineArray[1];
          const emptyLine = fileContent.indexOf("\n\n");
          const headersArray = fileContent.substring(firstNewLineIndex + 1, emptyLine).split("\n");
          let headers: any = {};
          let body = fileContent.substring(emptyLine + 2);

          headersArray.forEach(h => {
            const delimiterIndex = h.indexOf(":");
            const name = h.substring(0, delimiterIndex);
            const value = h.substring(delimiterIndex + 2);
            headers[name] = value;
          });

          //if full url is not in the request lets assume an http to host header
          let url: string;
          if (path.startsWith("http"))
            url = path;
          else
            url = "http://" + headers['host'] + path;

          //let axios calculate the length, since we may change it
          delete headers["content-length"];
          delete headers["Content-Length"];

          const tmp = Requester.preparePayload(headers, body, payload);
          headers = tmp[0];
          body = tmp[1];

          const r = Axios.default({
            method: method,
            url: url,
            headers: headers,
            httpsAgent: new Https.Agent({
              rejectUnauthorized: false
            }),
            data: body
          });


          resolve(r);
        }
        catch (ex) {
          console.error("Error parsing request file");
          console.error(ex);
        }


      });
    });
  }

  private static preparePayload(headers: any, body: string, payload: string) {

    const newHeaders: any = {};

    headers = Object.keys(headers).map((k: string) => {
      let v: string = headers[k];
      if (v.includes(PayloadGenerator.PLACEHOLDER))
        v = v.replace(PayloadGenerator.PLACEHOLDER, payload.replace("\n", ""));

      if (v.includes(PayloadGenerator.PLACEHOLDER_REQUEST_B64))
        v = v.replace(PayloadGenerator.PLACEHOLDER, Buffer.from(payload.replace("\n", "")).toString("base64"));

      newHeaders[k] = v;
    });

    if (body.includes(PayloadGenerator.PLACEHOLDER))
      body = body.replace(PayloadGenerator.PLACEHOLDER, payload);

    if (body.includes(PayloadGenerator.PLACEHOLDER_REQUEST_B64))
      body = body.replace(PayloadGenerator.PLACEHOLDER, Buffer.from(payload).toString("base64"));

    return [newHeaders, body];
  }



}